
# Eaas ou Encryption as a Service

---

### 1️⃣ `Présentation`
### 2️⃣ `Utilisation`


---

### 1️⃣ **Présentation**

-1. `Encryption as a Service (EaaS)`

La fonctionnalité **Encryption as a Service (EaaS)** de Vault permet de chiffrer et déchiffrer des données via API, sans que les applications aient à gérer elles-mêmes les clés de chiffrement.

`Principe`

1. L’application envoie une donnée à Vault.
2. Vault chiffre la donnée via le **Transit Engine**.
3. L’application stocke la donnée chiffrée (ex : en base de données).
4. Une application autorisée peut demander à Vault de la déchiffrer.

`Avantages`

- Centralisation de la gestion des clés
- Rotation automatique des clés
- Contrôle d’accès précis (ACL)
- Sécurisation des données sensibles
- Plusieurs applications peuvent utiliser les mêmes clés de manière sécurisée

`Important`

Vault ne chiffre pas directement la base de données complète.  
Il fournit un service de chiffrement que les applications utilisent avant de stocker les données.

`[EXEMPLE]`

<img width="1482" height="814" alt="image" src="https://github.com/user-attachments/assets/4ed706cf-58e8-4804-a910-d9b8d48d889a" />

---

`-1.` Moteurs Principaux

- **Encrypt/Decrypt**
- Moteur Vault qui permetent de chiffrer et déchiffrer de la données
L'application A ne fera que chiffrer et l'application B ne fera que déchiffrer

<img width="1844" height="952" alt="image" src="https://github.com/user-attachments/assets/6de5bbba-32d3-462d-9bc9-7433ad855a5f" />

-**Rotate & Warp**
- Rotate permet de faire de Rotation de clés de chiffrement 
- Rewrap  permet, lors de la rotation d’une clé, que les données puissent être déchiffrées avec la nouvelle clé (version 2) sans que l’application à l’origine de la demande de rotation n’ait besoin de déchiffrer les données en clair.
 C'est Vault qui effectue le déchiffrement et le rechiffrement automatiquement.

<img width="1894" height="1118" alt="image" src="https://github.com/user-attachments/assets/3ba1f437-f235-48af-ad93-52383ca5070b" />


**Datakey - Encryption**
- Cette méthode est utilisée lorsque des `fichiers volumineux ont besoin d'être chiffrés`.  
Pour éviter de trop nombreux call API, et par conséquent surcharger le réseau, `l'application chiffrera en local`.

`-1.` **Chiffrement**

- Pour ce faire, l'application va demander des datakey à Vault.

- Vault crée deux clés et les envoi à l'application :

-1- `plaintext datakey:` Elle servira à `chiffrer en local`.  
-2- `ciphertext datakey :` `Clé chiffrée`, et qui servira par la suite à `déchiffrer la donnée`.

- Les données sont envoyées chiffrées à Vault et stockées avec la ciphertext datakey correspondante (Pour déchiffrement => Texte chiffré correspond à une cyphertext datakey).

<img width="1284" height="870" alt="image" src="https://github.com/user-attachments/assets/8b05cc0b-3cc7-4eb9-a547-02059dfa8278" />

`-2.` **Déchiffrement**


`[RAPPEL]` L'application à accés à la cyphertext datakey via :

=> Datakey - Accès

- `Policy (secret)` → contrôle la lecture du `ciphertext datakey`
- `Role / AppRole (KMS)` → contrôle l’usage :
  - génération de datakey
  - déchiffrement du datakey
 => Policy = accès au secret, Role = permission d’utiliser la clé


1. L’app récupère :
   - données chiffrées
   - ciphertext datakey associé

2. L’app s’authentifie auprès de Vault (Role/AppRole)

3. L’app envoie le ciphertext datakey à Vault (decrypt)

4. Vault vérifie policy + role :
   - si OK → renvoie le plaintext datakey

5. L’app déchiffre localement les données

<img width="1196" height="889" alt="image" src="https://github.com/user-attachments/assets/cb8ff83a-abeb-4ad8-859b-ce49fd9c820b" />

**BYOK**

- Vault permet d'implémenter du **BYOK**
Ce ne sera pas dévelopé ici.

`[INFO]`

**BYOK vs HYOK**

`BYOK (Bring Your Own Key)`
- L’entreprise génère sa clé
- La clé est importée dans le KMS du cloud
- Le cloud l’utilise pour chiffrer/déchiffrer
- Le client garde le contrôle du cycle de vie (rotation, révocation)

 `HYOK (Hold Your Own Key)`
- La clé reste hors du cloud (on-prem / HSM)
- Le cloud ne stocke jamais la clé
- Chiffrement/déchiffrement dépend d’un système contrôlé par le client
- Niveau de contrôle et souveraineté maximal

[Doc BYOK Vault]( https://developer.hashicorp.com/vault/docs/secrets/transit#bring-your-own-key-byok)

---
---

### 2️⃣ **Utilisation**

`-1.` **Encrypt / Decrypt**

-1.1. Autoriser le moteur `transit`
```
vault secrets enable transit
```

- Sortie

 <img width="534" height="34" alt="image" src="https://github.com/user-attachments/assets/8774d619-5fe0-4b0b-9271-9b64cb5e3722" />


-1.2. Créer la `clé de chiffrement`
```
vault write -f transit/keys/test1
```

- Sortie

<img width="556" height="380" alt="image" src="https://github.com/user-attachments/assets/5da1100e-3911-4e70-bbea-066224eaa55a" />

-1.3. Créer une `policy` avec le moteur `transit` puis path `encrypt` et `decrypt` (Penser à créer une arborécence claire afin d'avoir un vision claire de Vault)
- Ici on utilise l'arborécence de `VaultTraining`
```
/home/sednal/
  │ 
  └── vault-config/
       ├── db_user
       │   └── static_user.sql
       ├── policies
       │   ├── apps
       │   ├── transit     <===
       │   │   ├── decrypt <===
       │   │   └── encrypt <===
       │   └── user
       │       ├── policy_user_auth.hcl
       │       └── user_ldap.hcl
       ├── role
       │   └── readonly.sql
       └── scripts


```

-Editer
```
nano /home/sednal/vault-config/policies/transit/encrypt/encrypt_file.hcl
```

- Pour encrypt
```
path "transit/encrypt/test1" {
   capabilities = [ "update" ]
}
```

-Editer
```
nano /home/sednal/vault-config/policies/transit/decrypt/decrypt_file.hcl
```

- Pour decrypt
```
path "transit/decrypt/test1" {
   capabilities = [ "update" ]
}
```

-1.4. `Intégrer` la policy à Vault
```
vault policy write test_transit_encrypt /home/sednal/vault-config/policies/transit/encrypt/encrypt_file.hcl
```

```
vault policy write test_transit_decrypt /home/sednal/vault-config/policies/transit/decrypt/decrypt_file.hcl
```

-Vérif

<img width="381" height="137" alt="image" src="https://github.com/user-attachments/assets/b7687a57-f424-445d-a7d1-f1e8ddff5818" />



-1.5. `[TEST]`

- `Encrypt`
```
vault write -f transit/encrypt/test1 plaintext=$(echo "test pour transit => text" | base64)
```

- Sortie Chiffrée (en K/V):
```
Key            Value
---            -----
ciphertext     vault:v1:7y0I/iEIRoEsRexJnwoAmH+ditLsanasV8dUIWXWg5+s/ZkBvzR/eAeWXGEjE3Gj4L3OD4Og
key_version    1
```

- `Decrypt`
```
vault write -force transit/decrypt/test1 ciphertext=vault:v1:7y0I/iEIRoEsRexJnwoAmH+ditLsanasV8dUIWXWg5+s/ZkBvzR/eAeWXGEjE3Gj4L3OD4Og
```

- Sortie texte déchiffré en base 64 
```
Key          Value
---          -----
plaintext    dGVzdCBwb3VyIHRyYW5zaXQgPT4gdGV4dAo=
```

- texte lisible
```
echo "dGVzdCBwb3VyIHRyYW5zaXQgPT4gdGV4dAo=" | base64 --decode
```

<img width="784" height="39" alt="image" src="https://github.com/user-attachments/assets/0aa8e0e5-1105-4c18-b8ea-06d0a5c459e6" />


---

`-2.` **Rotate key**

-2.1. Lister la clé présente sur Vault et voir les infos
```
vault list transit/keys
```
-Sortie 

```
Keys
----
test1
```

- Infos
```
vault read transit/keys/test1
```

- Ici on peux voir une seule version et que c'est la version [1]

<img width="496" height="388" alt="image" src="https://github.com/user-attachments/assets/a256f69a-07b8-451a-8c80-3cfc7953e6c5" />


-2.2. Rotation de la clé 2 fois
```
vault write -f /transit/keys/test1/rotate
```

- Sortie, Ici on voit que la clés à 3 versions et que la version dispo est la 3

<img width="635" height="381" alt="image" src="https://github.com/user-attachments/assets/fdbffbf3-f3f9-4355-ac86-12399ab534c8" />

-2.3. Variabilisé la donnée chiffrée avec la verion 3 de la clé
```
ENCRYPTED_SECRET=$(vault write -f -field="ciphertext" transit/encrypt/test1 plaintext=$(echo "test
 pour rewrap" | base64))
```

- lecture de la variable `ENCRYPTED_SECRET`
```
echo "$ENCRYPTED_SECRET"
```

- Sortie ici on voit bien que la variable contient uniquement le ciphertext, chiffré avec la v3 de la clé

<img width="676" height="45" alt="image" src="https://github.com/user-attachments/assets/20fec308-a986-432a-b430-d8296e2aaa3f" />

---

`-3.` **Rewrap**

Rewrap – Bonne pratique

Le **rewrap** est la méthode recommandée pour mettre à jour la version de clé d’un ciphertext.

`En environnement de test`
- Les opérations sont réalisées directement dans Vault.
- Aucun impact particulier.
- Les données ne sortent pas de Vault.

`En production`
- Si une application gère mal le processus,
  les données pourraient transiter en clair côté applicatif.
- Le **rewrap** évite cela :
  => le plaintext n’est jamais exposé
  => seule la version de clé est mise à jour

`[NOTE]` Pour le test Rewarp => Rotation de la clé (elle va passer en v4), mais `$ENCRYPTED_SECRET` restera sous version 3.

-3.1. Rotation de la clé et Sortie
```
vault write -f /transit/keys/test1/rotate
```

<img width="748" height="382" alt="image" src="https://github.com/user-attachments/assets/f27fb663-9f34-4488-a604-85b94c88cb67" />

-3.2.  `$ENCRYPTED_SECRET` est toujours en v3 

<img width="665" height="41" alt="image" src="https://github.com/user-attachments/assets/dfa672b8-5033-40af-b89b-64e21f535e93" />


-3.3. Rewarp 
```
vault write transit/rewrap/test1 ciphertext=$ENCRYPTED_SECRET
```

- Sortie du ciphertext v4

<img width="805" height="98" alt="image" src="https://github.com/user-attachments/assets/11749ee4-6eac-4878-84d5-8f9f1abf8207" />


-3.4. Déchiffrement
```
vault write -field=plaintext transit/decrypt/test1 ciphertext=$ENCRYPTED_SECRET | base64 --decode
```

<img width="1110" height="61" alt="image" src="https://github.com/user-attachments/assets/ff8d3ee2-ffeb-4cf6-b990-62bdb3347214" />


---
---

### **Pour allez plus loin**

Mise en place de l'autounseal en SSL => [Tuto AutoUnseal](https://github.com/NALSED/TUTO/blob/main/PERSO/VAULT/-2-HOMELAB/Auto_Unseal_Vault.md)


