
# Secret Engine Static

---

### 1️⃣ `Présentation`
### 2️⃣ `Utilisation`

---

## 1️⃣ **Présentation**

[DOC OFFICIEL](https://developer.hashicorp.com/vault/docs/secrets/kv)

### -1. `[NOTE]` 

Le **K/V secrets engine** et le **storage backend** interviennent à deux niveaux distincts de l’architecture Vault :

- **K/V secrets engine** : couche **applicative** offrant une abstraction logique et une interface pour gérer les secrets.
- **Storage backend** : couche **infrastructure** assurant la **persistance physique et chiffrée** des données.

=> Le K/V gère la logique des secrets, tandis que le storage backend stocke les données de manière sécurisée.

---

### -2. `K/V`

Le `K/V (Key/Value)` est un moteur de secrets dans Vault qui fournit `une couche logique d’abstraction` pour organiser, `structurer et contrôler` l’accès aux secrets par les utilisateurs et les applications.

`Rôle et fonctionnement du K/V`

Le **K/V secrets engine** permet de :

- Organiser les secrets en paires clé-valeur dans une arborescence hiérarchique  
- Exposer une API HTTP (CRUD : create, read, update, delete)  
- Appliquer un contrôle d’accès granulaire via des politiques  
- Gérer les métadonnées (timestamps, versions, etc.)  
- (KV v2) Gérer le cycle de vie : versioning, suppression logique et restauration  

### **Deux Versions**

| Caractéristique                     | KV v1                                   | KV v2                                                  |
|--------------------------------------|------------------------------------------|--------------------------------------------------------|
| Versioning                           | Non                                      | Oui (automatique à chaque modification)                |
| Gestion des versions                 | Une seule valeur actuelle                | Historique complet des versions                        |
| Suppression                          | Définitive                               | Logique (restauration possible)                        |
| Destruction définitive               | Oui (immédiate)                          | Oui (optionnelle après suppression logique)            |
| Métadonnées                          | Minimales                                | Enrichies (created_time, deletion_time, destroyed…)    |
| Performance / Complexité             | Plus simple et légèrement plus performant| Plus complet avec logique de gestion avancée           |
| Cas d’usage recommandé               | Secrets peu modifiés                     | Environnements nécessitant traçabilité et sécurité     |

### **Use Case**

| Cas d’usage                            | KV v1                                         | KV v2                                                    |
|----------------------------------------|-----------------------------------------------|----------------------------------------------------------|
| Type de secrets                        | Secrets qui changent rarement ou jamais      | Secrets qui changent régulièrement                       |
| Exemples                               | - Certificats SSL/TLS                         | - Passwords d’applications (rotation fréquente)         |
|                                        | - Clés API tierces (Stripe, Twilio)          | - Tokens temporaires                                     |
|                                        | - Configurations statiques                    | - Credentials nécessitant audit trail                    |
|                                        | - Secrets partagés entre équipes             | - Environnements de production                           |
|                                        | - Environnements simples (dev/test)          | - Compliance/réglementation (traçabilité requise)       |
| Avantages                              | Plus simple, léger, pas besoin d’historique  | Versioning, rollback, soft delete, audit                 |


---

### -3. `Policy, Actions Possibles et Commandes K/V v1`

-`Policy`

Les policy sont sensiblement les même que pour les autres parties de Vault

`[EXEMPLE_SYNTAXE]`

<img width="1250" height="693" alt="image" src="https://github.com/user-attachments/assets/d750a119-ad15-4c61-893b-8b0769b14ead" />

- Ici le seul chemin par defaut est `/secret`



- `Actions Possibles`

### KV v1

| Capabilities | HTTP verbs | Commande Vault |
|--------------|------------|----------------|
| create       | POST/PUT   | vault kv put   |
| read         | GET        | vault kv get   |
| update       | POST/PUT   | vault kv put   |
| delete       | DELETE     | vault kv delete|
| list         | LIST       | vault kv list  |


- `Commandes` (Non exaustives, à titre d'exemple...)
 
- **put** => créer un secret ou si existant update

`[EXPLICATION]`
```
vault kv put secret/access ttl=30m username=admin password=secret123                          
```
`[NOTE]` Le `ttl` est à titre indixatif pour l'utilisateur

- Sortie :
```
Success! Data written to: secret/access
```

```
vault kv put secret/access  ttl=30m username=admin password=secret123  
└───┘ └┘ └─┘ └────────────┘ └────┘ └────────────┘ └─────────────────┘
  │    │   │         │         │         │               |
  │    │   │         │         │         │               |
  │    │   │    Clé Vault    Arg 1      Arg 2          Arg 3
  │    │   │                                  
  │    │  Action                             
  │   Type                                   
 CLI                                         
```

⬆️

| Élément | Valeur | Rôle |
|---------|--------|------|
| `vault` | Commande de base | CLI Vault |
| `kv` | Sous-commande | Opération K/V |
| `put` | Action | Écrire/créer |
| `secret/access` | Chemin | **Clé Vault** |
| `ttl=30m` | Argument 1 | Paire clé-valeur JSON |
| `username=admin` | Argument 2 | Paire clé-valeur JSON |
| `password=secret123` | Argument 3 | Paire clé-valeur JSON |

- **get** Lit le secret
```
vault kv get secret/database
```

- Sortie :
```
====== Data ======
Key         Value
---         -----
password    secret123
username    admin
---
```

### -4. `Policy, Actions Possibles et Commandes K/V v2`

`[NOTE]` Possibilité de `Versioning

- `Policy`

Ici contrairement à KV v1, `KV v2` nécessite `/data/` ou `/database/` explicitement.
- `/data/` => Données
- /database/ => Métadonnées


<img width="1256" height="494" alt="image" src="https://github.com/user-attachments/assets/23c5c982-9268-4c97-b75f-f5d917fc3fe2" />


- `Actions Possibles`

### KV v2

| Capabilities | HTTP verbs | Commande Vault    |
|--------------|------------|-------------------|
| create       | POST/PUT   | vault kv put      |
| read         | GET        | vault kv get      |
| update       | POST/PUT   | vault kv put      |
| update       | POST/PUT   | vault kv undelete |
| delete       | DELETE     | vault kv destroy  |
| delete       | DELETE     | vault kv delete   |
| list         | LIST       | vault kv list     |
| patch        | PATCH      | vault kv patch    |

`[NOTE]` 

- Il est possible, avec `vault kv metadata put`, de **personnaliser les métadonnées**, par exemple le **nombre maximum de versions autorisées**.  

- Il est possible, avec `vault kv patch`, de **mettre à jour partiellement** une key value.  
  Par exemple, si une entrée contient `password = 12345`, on peut modifier uniquement `password` ou sa valeur `12345` sans toucher aux autres clés du secret.

Consultez la [documentation officielle](https://www.vaultproject.io/docs/secrets/kv) pour plus d'informations.

- Il est possible avec `vault kv get -wrap` d'enrober/chiffrer un secret.  
  Exemple : `vault kv get -wrap-ttl=120s secret/data/test`, et Vault va renvoyer un token, qui sera demandé pour unwrap avec `vault unwrap [token]`.  
  La commande `unwrap` ne marche qu'une seule fois, ce qui veut dire que même si quelqu'un essaie de déchiffrer le secret par la suite, c'est impossible.  

   **Utilité :** On peut envoyer des secrets wrappés par mail avec le token.

---
---

## 2️⃣ **Utilisation**

`[NOTE]` Pour rappel la syntaxe recommandé pour la création des secrets :

secret/[application]/[environnement]/[composant]

- exemple :
```
secret/netflix/
├── prod/
│   ├── postgres    (credentials DB production)
│   ├── redis       (cache production)
│   └── aws         (clés AWS production)
├── staging/
│   └── postgres    (DB de test)
└── dev/
    └── postgres    (DB locale développeur)
```

### -1. `Créer et manager un secret`

- 1.1 Autoriser/créer le moteur de secret
```
vault secrets enable -version=1 kv
```

-Ici `kv` est le nom, mais choix libre.

- 1.2 Créer un secret
```
vault kv put kv/test password=12345
```

- 1.3 Lister
```
vault kv list kv/
```

-Sortie
```
Keys
----
test
```

- 1.4 Lire le/les Key Value
```
vault kv get kv/test
```

- Sortie
```
====== Data ======
Key         Value
---         -----
password    12345
```

- 1.5 Ajouter un secret dans test ([RAPPEL] cela ecrase la donnée précédente)
```
vault kv put kv/test user=bob
vault kv get kv/test
==== Data ====
Key     Value
---     -----
user    bob
```

- 1.6 Supprimer un secret
```
vault kv delete kv/test
```

### -2. `Mettre à niveau vers KV v2`
```
vault kv enable-versioning kv/
```

### -3. `Utiliser le versioning de KV v2`

- 3.1 Création d'un secret avec versioning
```
vault kv put kv/test user=bob
```

- Sortie
```== Secret Path ==
kv/data/test

======= Metadata =======
Key                Value
---                -----
created_time       2026-02-16T17:41:11.123762309Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1 
```

- 3.2 Lecture du secret
```
vault kv get kv/test
```

- Sortie
```
== Secret Path ==
kv/data/test

======= Metadata =======
Key                Value
---                -----
created_time       2026-02-16T17:41:11.123762309Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

==== Data ====
Key     Value
---     -----
user    bob
```

- 3.3 Avoir une Sortie détaillée de la métadata
```
vault kv metadata get kv/test
```

-Sortie
```
= Metadata Path =
kv/metadata/test

========== Metadata ==========
Key                     Value
---                     -----
cas_required            false
created_time            2026-02-16T17:41:11.123762309Z
current_version         1
custom_metadata         <nil>
delete_version_after    0s
last_updated_by         map[actor:root client_id:0DHqvq2D77kL2/JTPSZkTMJbkFVmUu0TzMi0jiXcFy8= operation:update]
max_versions            0
oldest_version          0
updated_time            2026-02-16T17:52:43.412611838Z

====== Version 1 ======
Key              Value
---              -----
created_by       {"actor":"root","client_id":"0DHqvq2D77kL2/JTPSZkTMJbkFVmUu0TzMi0jiXcFy8=","operation":"create"}
created_time     2026-02-16T17:41:11.123762309Z
deleted_by       <nil>
deletion_time    n/a
destroyed        false
```

-3.4 Modifier la value de la key test, puis utiliser le versioning pour restaurer la version 1.

- Modification value 
```
vault kv put kv/test user=alice
```

- Sortie (On voit bien que le versioning fonctionne)
```
== Secret Path ==
kv/data/test

======= Metadata =======
Key                Value
---                -----
created_time       2026-02-16T17:52:43.412611838Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            2
```

- Lecture du secret version 2 :
```
vault kv get kv/test
```

-Sortie (La value à bien changée)
```
== Secret Path ==
kv/data/test

======= Metadata =======
Key                Value
---                -----
created_time       2026-02-16T17:52:43.412611838Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            2

==== Data ====
Key     Value
---     -----
user    alice
```

`[NOTE]` Si l'on refait un get sur les metadata, toutes les version ainsi que les informations les concernants seront présentes.

```
vault kv metadata get kv/test

= Metadata Path =
kv/metadata/test

========== Metadata ==========
Key                     Value
---                     -----
cas_required            false
created_time            2026-02-16T17:41:11.123762309Z
current_version         2
custom_metadata         <nil>
delete_version_after    0s
last_updated_by         map[actor:root client_id:0DHqvq2D77kL2/JTPSZkTMJbkFVmUu0TzMi0jiXcFy8= operation:update]
max_versions            0
oldest_version          0
updated_time            2026-02-16T17:52:43.412611838Z

====== Version 1 ======
Key              Value
---              -----
created_by       {"actor":"root","client_id":"0DHqvq2D77kL2/JTPSZkTMJbkFVmUu0TzMi0jiXcFy8=","operation":"create"}
created_time     2026-02-16T17:41:11.123762309Z
deleted_by       <nil>
deletion_time    n/a
destroyed        false

====== Version 2 ======
Key              Value
---              -----
created_by       {"actor":"root","client_id":"0DHqvq2D77kL2/JTPSZkTMJbkFVmUu0TzMi0jiXcFy8=","operation":"update"}
created_time     2026-02-16T17:52:43.412611838Z
deleted_by       <nil>
deletion_time    n/a
destroyed        false
```

⚠️ Lorsque l’on passe d’une version 1 => 2 => 3, toutes les versions restent en mémoire : elles ne sont pas effacées.  
Avec la commande `vault kv get -version=<numéro> [PATH]`, il est possible de les récupérer.

- Revenir à la version 1 du secret
```
vault kv get -version=1 kv/test
```

- Sortie
```
== Secret Path ==
kv/data/test

======= Metadata =======
Key                Value
---                -----
created_time       2026-02-16T17:41:11.123762309Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

==== Data ====
Key     Value
---     -----
user    bob
```



### -4. `Supprimer et restaurer un secret`

- Supprimer un secret
```
 vault kv delete kv/test
```

- Ici avec un `vault kv get -version=1 kv/test` on à bien la metadata et la data, mais avec `version=2` rien.

- Restaurer les données de version 2 (Ici versions on peut par conséquent mettre plusieurs versions)
```
vault kv undelete -versions=2 kv/test
```

### -5. `Wrap un secret`

- Wrap kv/test
```
vault kv get -wrap-ttl=1200 kv/test
```

- Sortie
```
Key                              Value
---                              -----
wrapping_token:                  [TOKEN]
wrapping_accessor:               0UGYvzo8m6hDZPQtAJWjypRV
wrapping_token_ttl:              20m
wrapping_token_creation_time:    2026-02-17 07:29:06.585715833 +0100 CET
wrapping_token_creation_path:    kv/data/test
```

`[NOTE]` Ici le token accessor est utile pour notement voir si le secret peux encore être `unwrap` sont ttl, etc..
- pour Rappel => `Vault token lookup -accessor [TOKEN ACCESSOR]` 

- Unwrap un secret
```
vault unwrap [WRAP TOKEN]
```

-Sortie 
```
Key         Value
---         -----
data        map[user:alice]
metadata    map[created_time:2026-02-16T17:52:43.412611838Z custom_metadata:<nil> deletion_time: destroyed:false version:2]
```

### -6. `Détruire un secret` (Suppression permanente)

- Supression data
```
vault kv destroy -versions=2 kv/test
```

- Supression complete (metadata)
```
vault kv metadata delete kv/test
```

---
---

 [CHOSES A RETENIR]

